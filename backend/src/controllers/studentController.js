const bcrypt = require("bcryptjs");
const { validationResult } = require("express-validator");
const { checkStudentNumberExists, registerStudent, getAllStudents, getStudentById, updateStudent, softDeleteStudent, restoreStudent, resetStudentPassword,bulkDeleteArchivedStudentsByCourse, bulkDeleteStudentsByCourse,deleteStudentPermanently, deleteAllStudents, unlockStudentAccount, processBatchStudents, changePassword } = require("../models/studentModel");
const XLSX = require('xlsx');
const fs = require('fs');
const path = require('path');
const pool = require("../config/db");

const buildAbsoluteUrl = (req, relativePath) => {
  if (!relativePath) return null;
  let basePath = relativePath.startsWith('/') ? relativePath : `/${relativePath}`;
  // Normalize to /api/uploads if the path starts with /uploads
  if (basePath.startsWith('/uploads/')) {
    basePath = `/api${basePath}`; // serve under /api/uploads as well
  }
  const protocol = req.protocol;
  const host = req.get('host');
  return `${protocol}://${host}${basePath}`;
};

const generateStudentPassword = (lastName, studentNumber) => {
  // Format lastName to proper case (Title Case)
  const formattedLastName = lastName.toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  const lastThreeDigits = studentNumber.slice(-3);
  const specialCharacter = "!";
  return `${formattedLastName}${lastThreeDigits}${specialCharacter}`;
}

const isValidStudentEmail = (email, studentNumber, lastName) => {
  const lastSixDigits = studentNumber.slice(-6); 
  const expectedEmailLong = `${lastName.toLowerCase()}.${lastSixDigits}@novaliches.sti.edu.ph`;
  const expectedEmailShort = `${lastName.toLowerCase()}.${lastSixDigits}@novaliches.sti.edu`;
  return email.toLowerCase() === expectedEmailLong || email.toLowerCase() === expectedEmailShort;
};

const normalizeForEmail = (text) => {
  if (!text) return '';

  let normalized = text.toLowerCase().replace(/\s+/g, '');
  
  // Replace Spanish characters with their ASCII equivalents
  const charMap = {
    'á': 'a', 'é': 'e', 'í': 'i', 'ó': 'o', 'ú': 'u',
    'ü': 'u', 'ñ': 'n', 'ç': 'c', 'à': 'a', 'è': 'e',
    'ì': 'i', 'ò': 'o', 'ù': 'u'
  };
  
  return normalized.replace(/[áéíóúüñçàèìòù]/g, match => charMap[match] || match);
};

exports.registerStudent = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { firstName, middleName, lastName, email, studentNumber, courseName, courseId, yearLevel, gender, birthdate, password, createdBy } = req.body;

    const studentExists = await checkStudentNumberExists(studentNumber);
    if (studentExists) {
      return res.status(400).json({ message: "Student number already exists" });
    }

    let hashedPassword;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
    } else {
      const autoGeneratedPassword = generateStudentPassword(lastName, studentNumber);
      hashedPassword = await bcrypt.hash(autoGeneratedPassword, 10);
    }

    let processedMiddleName = null;
    if (middleName !== undefined && middleName !== null) {
      const middleNameStr = String(middleName).trim();
      if (middleNameStr.length > 0) {
        processedMiddleName = middleNameStr;
      }
    }

    let processedBirthdate = null;
    if (birthdate) {
      try {
        processedBirthdate = new Date(birthdate);
        if (isNaN(processedBirthdate.getTime())) {
          return res.status(400).json({ message: "Invalid birthdate format" });
        }
      } catch (error) {
        return res.status(400).json({ message: "Invalid birthdate format" });
      }
    }

    let studentEmail = email;
    if (!studentEmail) {

      const normalizedLastName = normalizeForEmail(lastName);
      const lastSixDigits = studentNumber.slice(-6);
      studentEmail = `${normalizedLastName}.${lastSixDigits}@novaliches.sti.edu.ph`;
    }

    const student = await registerStudent(
      firstName,
      processedMiddleName,
      lastName,
      studentEmail,
      studentEmail, 
      hashedPassword,
      studentNumber,
      courseName,
      yearLevel,
      gender,
      processedBirthdate,
      createdBy,
      courseId
    );

    res.status(201).json({
      success: true,
      message: "Student registered successfully",
      student,
    });
  } catch (error) {
    console.error("Registration Error:", error);
    
    let errorMessage = error.message;

    if (error.code === '23503' && error.constraint === 'students_course_name_fkey') {
      errorMessage = `The course '${req.body.courseName}' does not exist in the database. Please add it first or use a valid course.`;
    }
    
    res.status(500).json({
      message: "Failed to register student",
      error: errorMessage,
    });
  }
};

exports.getAllStudents = async (req, res) => {
  try {
    const students = await getAllStudents();
    res.status(200).json({ students });
  } catch (error) {
    console.error("Error fetching students:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.getStudentById = async (req, res) => {
  try {
    const studentId = req.params.id;
    const student = await getStudentById(studentId);

    if (!student) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ student });
  } catch (error) {
    console.error("Error fetching student by ID:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.editStudent = async (req, res) => {
  try {
    const studentId = req.params.id;
    const { firstName, middleName, lastName, courseName, yearLevel, gender, birthdate } = req.body;

    if (!firstName || !lastName || !courseName || !yearLevel || !gender) {
      return res.status(400).json({ message: "All required fields must be provided" });
    }

    const updatedStudent = await updateStudent(studentId, firstName, middleName, lastName, courseName, yearLevel, gender, birthdate ? new Date(birthdate) : null);

    if (!updatedStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student updated successfully", student: updatedStudent });
  } catch (error) {
    console.error("Error updating student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.deleteStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const deletedStudent = await softDeleteStudent(studentId);
    if (!deletedStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student deleted successfully (soft delete)", student: deletedStudent });
  } catch (error) {
    console.error("Error deleting student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.restoreStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const restoredStudent = await restoreStudent(studentId);
    if (!restoredStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student restored successfully", student: restoredStudent });
  } catch (error) {
    console.error("Error restoring student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.resetStudentPassword = async (req, res) => {
  try {
    const { studentId, newPassword } = req.body;

    if (!studentId || !newPassword) {
      return res.status(400).json({ message: "Student ID and new password are required." });
    }

    const passwordRegex = /^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    if (!passwordRegex.test(newPassword)) {
      return res.status(400).json({ message: "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character." });
    }

    const updatedStudent = await resetStudentPassword(studentId, newPassword);
    if (!updatedStudent) {
      return res.status(404).json({ message: "Student not found or not linked to a user." });
    }

    res.status(200).json({ message: "Student password reset successfully", student: updatedStudent });
  } catch (error) {
    console.error("Error resetting student password:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.permanentDeleteStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const deletedStudent = await deleteStudentPermanently(studentId);
    if (!deletedStudent) {
      return res.status(404).json({ message: "Student not found or already deleted permanently." });
    }

    res.status(200).json({ message: "Student permanently deleted." });
  } catch (error) {
    console.error("Error permanently deleting student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.unlockStudentAccount = async (req, res) => {
  try {
    const studentId = req.params.id;
    const unlockedAccount = await unlockStudentAccount(studentId);
    
    if (!unlockedAccount) {
      return res.status(404).json({ message: "Student not found" });
    }
    
    res.status(200).json({ message: "Student account unlocked successfully" });
  } catch (error) {
    console.error("Error unlocking student account:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.uploadStudentsBatch = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
    if (!req.body.createdBy) {
      return res.status(400).json({ message: 'Super Admin ID is required' });
    }

    const filePath = path.resolve(req.file.path);
    
    if (!fs.existsSync(filePath)) {
      throw new Error('Uploaded file not found');
    }

    const workbook = XLSX.read(fs.readFileSync(filePath));
    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
    
    // Try to detect the actual header row by looking for meaningful column names
    let jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 }); // Get raw data as arrays
    
    if (jsonData.length === 0) {
      return res.status(400).json({ message: 'Excel file contains no data' });
    }

    // Find the header row by looking for common student data column names
    let headerRowIndex = 0;
    let bestHeaderRow = 0;
    let maxMatches = 0;
    
    for (let i = 0; i < Math.min(jsonData.length, 10); i++) { // Check first 10 rows
      const row = jsonData[i];
      if (!row || row.length === 0) continue;
      
      const rowText = row.join(' ').toLowerCase();
      const matches = [
        'first', 'last', 'name', 'student', 'number', 'course', 'year', 'level', 'gender'
      ].filter(keyword => rowText.includes(keyword)).length;
      
      if (matches > maxMatches) {
        maxMatches = matches;
        bestHeaderRow = i;
      }
    }
    
    headerRowIndex = bestHeaderRow;
    
    // If no good header row found, try to use the first row and clean it up
    if (maxMatches === 0) {
      headerRowIndex = 0;
    }
    
    // Extract headers from the best row
    const headers = jsonData[headerRowIndex] || [];
    
    // Clean up headers - remove empty ones and normalize
    const cleanHeaders = headers.map((header, index) => {
      if (!header || String(header).trim() === '' || String(header).startsWith('_EMPTY')) {
        return `Column_${index + 1}`; // Give empty columns a generic name
      }
      return String(header).trim();
    });
    
    // Convert to JSON format using the cleaned headers
    const dataRows = jsonData.slice(headerRowIndex + 1);
    jsonData = dataRows.map(row => {
      const obj = {};
      cleanHeaders.forEach((header, index) => {
        obj[header] = row[index] || '';
      });
      return obj;
    }).filter(row => {
      // Filter out completely empty rows
      return Object.values(row).some(value => value && String(value).trim() !== '');
    });
    
    // If we still have no data after processing, return an error
    if (jsonData.length === 0) {
      return res.status(400).json({ 
        message: 'No valid data found in Excel file. Please check that your file has proper column headers and data.',
        debug: {
          originalHeaders: headers,
          cleanedHeaders: cleanHeaders,
          headerRowIndex: headerRowIndex,
          totalRows: dataRows.length
        }
      });
    }

    jsonData = jsonData.map((row, index) => {
      const normalizedRow = {};

      Object.keys(row).forEach(key => {
        // More comprehensive column name normalization
        const normalizedKey = key.toLowerCase()
          .replace(/\s+/g, '')           // Remove all spaces
          .replace(/[_-]/g, '')          // Remove underscores and hyphens
          .replace(/\./g, '')            // Remove dots
          .trim();

        // Debug logging (only in development)
        if (process.env.NODE_ENV === 'production') {
        }
      
        // Map various possible column names to our expected format
        // Use more flexible matching that looks for keywords within the column name
        if (normalizedKey.includes('first') && normalizedKey.includes('name')) {
          normalizedRow.firstName = row[key];
        } else if (normalizedKey.includes('middle') && normalizedKey.includes('name')) {
          normalizedRow.middleName = row[key];
        } else if ((normalizedKey.includes('last') && normalizedKey.includes('name')) || 
                   normalizedKey.includes('surname') || normalizedKey.includes('family')) {
          normalizedRow.lastName = row[key];
        } else if ((normalizedKey.includes('student') && normalizedKey.includes('number')) ||
                   (normalizedKey.includes('student') && normalizedKey.includes('id')) ||
                   normalizedKey.includes('studentno') || normalizedKey.includes('studentnum') ||
                   (normalizedKey.includes('id') && !normalizedKey.includes('email'))) {
          normalizedRow.studentNumber = String(row[key]); // Ensure it's a string
        } else if (normalizedKey.includes('course') || normalizedKey.includes('program') || 
                   normalizedKey.includes('degree') || normalizedKey.includes('major')) {
          normalizedRow.courseName = row[key];
        } else if ((normalizedKey.includes('year') && normalizedKey.includes('level')) ||
                   normalizedKey.includes('grade') || normalizedKey.includes('class') ||
                   normalizedKey.includes('academicyear')) {
          normalizedRow.yearLevel = row[key];
        } else if (normalizedKey.includes('gender') || normalizedKey.includes('sex')) {
          normalizedRow.gender = row[key];
        } else if (normalizedKey.includes('birth') || normalizedKey.includes('dob')) {
          normalizedRow.birthdate = row[key];
        } else if (normalizedKey.includes('email') || normalizedKey.includes('mail')) {
          normalizedRow.email = row[key];
        } else {
          // Keep original column for debugging
          normalizedRow[key] = row[key];
        }
      });
      
      // Debug logging (only in development)
      if (process.env.NODE_ENV === 'development') {
      }
      return normalizedRow;
    });
    const requiredFields = ['firstName', 'lastName', 'studentNumber', 'courseName', 'yearLevel', 'gender'];
    const invalidRows = [];
    const validatedData = [];
    
    jsonData.forEach((student, index) => {
      const missingFields = [];
      const rowNum = index + 2; 

      requiredFields.forEach(field => {
        if (student[field] === undefined || student[field] === null || String(student[field]).trim() === '') {
          missingFields.push(field);
        }
      });
      
      if (missingFields.length > 0) {     
        // Provide more detailed error information
        const availableColumns = Object.keys(student).filter(key => student[key] !== undefined && student[key] !== null && String(student[key]).trim() !== '');
        const errorMessage = `Missing required fields: ${missingFields.join(', ')}. Available columns: ${availableColumns.join(', ')}`;
        
        invalidRows.push({
          row: rowNum,
          studentNumber: student.studentNumber || 'Unknown',
          firstName: student.firstName || 'Unknown',
          lastName: student.lastName || 'Unknown',
          error: errorMessage
        });
      } else {
      
        if (student.studentNumber && !/^02000[0-9]{6}$/.test(student.studentNumber)) {
          invalidRows.push({
            row: rowNum,
            studentNumber: student.studentNumber,
            firstName: student.firstName || 'Unknown',
            lastName: student.lastName || 'Unknown',
            error: 'Invalid student number format. Must be 11 digits starting with 02000'
          });
          return; 
        }

        if (!student.email) {
          const normalizedLastName = normalizeForEmail(student.lastName);
          const lastSixDigits = student.studentNumber.slice(-6);
          student.email = `${normalizedLastName}.${lastSixDigits}@novaliches.sti.edu.ph`;      
        }

        if (student.yearLevel) {
          const yearLevelStr = String(student.yearLevel).trim();
          let year = null;

          const startsWithNumberMatch = yearLevelStr.match(/^(\d)/);
          if (startsWithNumberMatch) {
            year = parseInt(startsWithNumberMatch[1]);
          } 
          else if (yearLevelStr.toLowerCase().includes('first') || yearLevelStr.toLowerCase().includes('1st')) {
            year = 1;
          }
          else if (yearLevelStr.toLowerCase().includes('second') || yearLevelStr.toLowerCase().includes('2nd')) {
            year = 2;
          }
          else if (yearLevelStr.toLowerCase().includes('third') || yearLevelStr.toLowerCase().includes('3rd')) {
            year = 3;
          }
          else if (yearLevelStr.toLowerCase().includes('fourth') || yearLevelStr.toLowerCase().includes('4th')) {
            year = 4;
          }
          // Handle senior high school year levels
          else if (yearLevelStr.toLowerCase() === 'g11' || yearLevelStr.toLowerCase() === 'grade 11') {
            student.yearLevel = 'Grade 11';
            validatedData.push(student);
            return; // Skip the rest of the validation for year level
          }
          else if (yearLevelStr.toLowerCase() === 'g12' || yearLevelStr.toLowerCase() === 'grade 12') {
            student.yearLevel = 'Grade 12';
            validatedData.push(student);
            return; // Skip the rest of the validation for year level
          }

          if (year >= 1 && year <= 4) {
            const yearLevelMap = {
              1: "1st Year",
              2: "2nd Year",
              3: "3rd Year",
              4: "4th Year"
            };
            student.yearLevel = yearLevelMap[year];
          } else {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: `Invalid year level: "${yearLevelStr}". Must be 1st-4th Year, G11, G12, or contain a digit 1-4.`
            });
            return; 
          }
        }

        if (student.gender) {
          const normalizedGender = student.gender.toString().trim().toLowerCase();
          if (normalizedGender === 'male' || normalizedGender === 'm') {
            student.gender = 'Male'; 
          } else if (normalizedGender === 'female' || normalizedGender === 'f') {
            student.gender = 'Female'; 
          } else {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: 'Invalid gender. Must be either "Male" or "Female"'
            });
            return; 
          }
        }

        if (student.birthdate) {
          try {
            const date = new Date(student.birthdate);
            if (isNaN(date.getTime())) {
              invalidRows.push({
                row: rowNum,
                studentNumber: student.studentNumber,
                firstName: student.firstName || 'Unknown',
                lastName: student.lastName || 'Unknown',
                error: 'Invalid birthdate format'
              });
              return; 
            }
          } catch (e) {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: 'Invalid birthdate format'
            });
            return; 
          }
        }

        validatedData.push(student);
      }
    });
    
    
    if (validatedData.length === 0 && invalidRows.length > 0) {
      return res.status(400).json({
        message: 'All rows in the Excel file contain errors',
        errors: invalidRows
      });
    }

    const uniqueCourseNames = new Set();
    validatedData.forEach(student => {
      if (student.courseName) {
        uniqueCourseNames.add(student.courseName.trim());
      }
    });

    if (uniqueCourseNames.size > 0) {

      const existingCoursesResult = await pool.query(
        "SELECT course_name FROM courses"
      );
      const existingCourses = new Set(
        existingCoursesResult.rows.map(course => course.course_name.toLowerCase())
      );

      for (const courseName of uniqueCourseNames) {
        if (!existingCourses.has(courseName.toLowerCase())) {
          try {
            await pool.query(
              "INSERT INTO courses (course_name) VALUES ($1) ON CONFLICT DO NOTHING",
              [courseName]
            );
           
          } catch (error) {
            console.error(`Failed to add course ${courseName}:`, error);
          }
        }
      }
    }

    const result = await processBatchStudents(validatedData, req.body.createdBy);

    try {
      fs.unlinkSync(filePath);
    } catch (unlinkError) {
      console.error('Error deleting temp file:', unlinkError);
    }

    const allErrors = [...invalidRows];
    if (result.errors && result.errors.length > 0) {
      allErrors.push(...result.errors);
    }

    // Get detected columns for debugging
    const detectedColumns = jsonData.length > 0 ? Object.keys(jsonData[0]) : [];
    const mappedColumns = {
      firstName: jsonData.some(row => row.firstName !== undefined),
      lastName: jsonData.some(row => row.lastName !== undefined),
      studentNumber: jsonData.some(row => row.studentNumber !== undefined),
      courseName: jsonData.some(row => row.courseName !== undefined),
      yearLevel: jsonData.some(row => row.yearLevel !== undefined),
      gender: jsonData.some(row => row.gender !== undefined)
    };

    res.status(200).json({
      message: 'Batch upload processed',
      total: jsonData.length,
      success: result.success,
      failed: invalidRows.length + result.failed,
      errors: allErrors,
      debug: {
        detectedColumns: detectedColumns,
        mappedColumns: mappedColumns,
        sampleData: jsonData.slice(0, 2) 
      }
    });
  } catch (error) {
    console.error('Error processing batch upload:', error);
    res.status(500).json({ 
      message: 'Error processing batch upload',
      error: error.message,
      stack: error.stack 
    });
  }
};

exports.getStudentElections = async (req, res) => {
  try {
   
    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
    
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
  
    let studentResult;
    
    try {
 
      if (studentId) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE id = $1 AND is_active = TRUE
        `, [studentId]);
      }
      

      if (!studentId || studentResult.rows.length === 0) {
        studentResult = await pool.query(`
          SELECT s.id 
          FROM students s
          JOIN users u ON s.email = u.email
          WHERE u.id = $1 AND s.is_active = TRUE
        `, [userId]);
      }
      
      if (studentResult.rows.length === 0) {
        return res.status(404).json({ message: "Student record not found for this user" });
      }
      
      const actualStudentId = studentResult.rows[0].id;
      const elections = await pool.query(`
        SELECT 
          e.id, e.title, e.description, 
          e.date_from, e.date_to,
          e.start_time, e.end_time,
          e.status,
          ev.has_voted,
          (SELECT COUNT(*) FROM eligible_voters WHERE election_id = e.id) AS voter_count,
          (SELECT COUNT(*) FROM eligible_voters WHERE election_id = e.id AND has_voted = TRUE) AS vote_count,
          EXISTS (
            SELECT 1 FROM ballots b 
            WHERE b.election_id = e.id
          ) AS ballot_exists,
          CASE
            WHEN EXISTS (
              SELECT 1 FROM users u 
              WHERE u.id = e.created_by 
              AND u.role_id = 1
            ) THEN TRUE
            ELSE e.needs_approval = FALSE OR e.status = 'approved'
          END as is_available
        FROM elections e
        INNER JOIN eligible_voters ev ON e.id = ev.election_id
        WHERE ev.student_id = $1
        AND e.status != 'draft'
        AND (
          (e.needs_approval = FALSE AND e.status != 'draft')
          OR 
          (e.status = 'approved' AND e.needs_approval = TRUE)
          OR
          EXISTS (
            SELECT 1 FROM users u 
            WHERE u.id = e.created_by 
            AND u.role_id = 1
          )
        )
        ORDER BY 
          CASE 
            WHEN e.status = 'ongoing' THEN 1
            WHEN e.status = 'upcoming' THEN 2
            ELSE 3
          END, 
          e.date_from
      `, [actualStudentId]);
      

      const result = elections.rows.map(election => ({
        ...election,
        has_voted: election.has_voted
      }));
      
      return res.json(result);
      
    } catch (err) {
      console.error("Database error in getStudentElections:", err);
      return res.status(500).json({ error: 'Database error: ' + err.message });
    }
  } catch (err) {
    console.error("General error in getStudentElections:", err);
    return res.status(500).json({ error: 'Failed to fetch elections: ' + err.message });
  }
};

exports.getStudentProfile = async (req, res) => {
  try {

    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }  
    let result;
    
    try {

      if (studentId) {
        result = await pool.query(`
          SELECT 
            s.id, 
            s.first_name AS "firstName", 
            s.middle_name AS "middleName",
            s.last_name AS "lastName", 
            s.email, 
            s.student_number AS "studentNumber", 
            s.course_name AS "courseName", 
            s.year_level AS "yearLevel", 
            s.gender,
            s.birthdate,
            s.profile_picture,
            COUNT(DISTINCT ev.election_id) AS "totalEligibleElections",
            SUM(CASE WHEN ev.has_voted = TRUE THEN 1 ELSE 0 END) AS "votedElections"
          FROM students s
          LEFT JOIN eligible_voters ev ON s.id = ev.student_id
          WHERE s.id = $1 AND s.is_active = TRUE
          GROUP BY s.id
        `, [studentId]);
      }
      
 
      if (!studentId || result.rows.length === 0) {
        result = await pool.query(`
          SELECT 
            s.id, 
            s.first_name AS "firstName", 
            s.middle_name AS "middleName",
            s.last_name AS "lastName", 
            s.email, 
            s.student_number AS "studentNumber", 
            s.course_name AS "courseName", 
            s.year_level AS "yearLevel", 
            s.gender,
            s.birthdate,
            s.profile_picture,
            COUNT(DISTINCT ev.election_id) AS "totalEligibleElections",
            SUM(CASE WHEN ev.has_voted = TRUE THEN 1 ELSE 0 END) AS "votedElections"
          FROM students s
          LEFT JOIN eligible_voters ev ON s.id = ev.student_id
          WHERE s.user_id = $1 AND s.is_active = TRUE
          GROUP BY s.id
        `, [userId]);
      }
      
      if (result.rows.length === 0) {
        return res.status(404).json({ message: "Student profile not found" });
      }

      const profile = result.rows[0];
      const filePath = profile.profile_picture ? `/uploads/profiles/${profile.profile_picture}` : null;
      const absoluteUrl = buildAbsoluteUrl(req, filePath);

      return res.status(200).json({
        ...profile,
        profile_picture: absoluteUrl || null
      });
      
    } catch (err) {
      console.error("Database error in getStudentProfile:", err);
      return res.status(500).json({ message: "Database error: " + err.message });
    }
  } catch (error) {
    console.error("General error in getStudentProfile:", error);
    return res.status(500).json({ message: "Failed to fetch student profile: " + error.message });
  }
};

exports.uploadProfilePicture = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }
    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
  
    let studentResult;
    
    try {
    
      if (studentId) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE id = $1 AND is_active = TRUE
        `, [studentId]);
      }
      
      if (!studentId || studentResult.rows.length === 0) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE user_id = $1 AND is_active = TRUE
        `, [userId]);
      }
      
      if (studentResult.rows.length === 0) {
        return res.status(404).json({ message: "Student record not found for this user" });
      }
      
      const actualStudentId = studentResult.rows[0].id;
      
      await pool.query(`
        UPDATE students 
        SET profile_picture = $1 
        WHERE id = $2
      `, [req.file.filename, actualStudentId]);
      
      const filePath = `/uploads/profiles/${req.file.filename}`;
      const absoluteUrl = buildAbsoluteUrl(req, filePath);
      
      return res.json({ 
        success: true, 
        filePath: filePath,
        url: absoluteUrl
      });
    } catch (err) {
      console.error("Database error in uploadProfilePicture:", err);
      return res.status(500).json({ message: "Database error: " + err.message });
    }
  } catch (error) {
    console.error("Error uploading file:", error);
    return res.status(500).json({ message: "Server error", error });
  }
};

exports.getStudentsByCourses = async (req, res) => {
  try {
   
    const { courses } = req.query;
    
    if (!courses) {
      return res.status(400).json({ success: false, message: "Courses parameter is required" });
    }

    const courseList = courses.split(',').map(course => course.trim());
    
    if (courseList.length === 0) {
      return res.status(400).json({ success: false, message: "At least one course must be provided" });
    }

    const courseRegex = /^[a-zA-Z0-9\s\-_.,()]{1,100}$/;
    for (const course of courseList) {
      if (!courseRegex.test(course)) {
        return res.status(400).json({ 
          success: false, 
          message: `Invalid course name format: ${course}. Only alphanumeric characters, spaces, and common punctuation are allowed.` 
        });
      }
    }
  
    let query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.middle_name,
        s.last_name, 
        s.email, 
        s.student_number, 
        s.course_name, 
        s.year_level, 
        s.gender, 
        s.birthdate,
        s.is_active,
        u.is_locked,
        u.locked_until
      FROM students s
      JOIN users u ON s.user_id = u.id
      WHERE s.course_name IN (`;

    const placeholders = courseList.map((_, index) => `$${index + 1}`).join(',');
    query += `${placeholders}) ORDER BY s.last_name ASC`;
    
    const result = await pool.query(query, courseList);
    
    return res.status(200).json(result.rows);
  } catch (error) {
    console.error("Error fetching students by courses:", error);
    return res.status(500).json({ 
      success: false, 
      message: "Failed to fetch students by courses",
      error: error.message 
    });
  }
};

exports.validateStudentByNumber = async (req, res) => {
  try {
    const { studentNumber } = req.query;
 
    
    if (!studentNumber) {
      return res.status(400).json({ 
        success: false, 
        message: "Student number is required" 
      });
    }
    
    // Validate student number format
    if (!/^02000[0-9]{6}$/.test(studentNumber)) {

      return res.status(400).json({
        success: false,
        message: "Invalid student number format. Must be 11 digits starting with 02000"
      });
    }
    
    // Query to find the student
    const query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.last_name, 
        s.student_number, 
        s.course_name,
        s.year_level,
        s.is_active
      FROM students s
      WHERE s.student_number = $1 AND s.is_active = TRUE
    `;
    
    const result = await pool.query(query, [studentNumber]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Student not found or inactive"
      });
    }
    
    return res.status(200).json({
      success: true,
      student: result.rows[0]
    });
  } catch (error) {
    console.error("Error validating student:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to validate student",
      error: error.message
    });
  }
};

exports.searchStudents = async (req, res) => {
  try {
    const { term } = req.query;
    
    if (!term || term.length < 4) {
      return res.status(400).json({ 
        success: false, 
        message: "Search term must be at least 4 characters" 
      });
    }
    
    // Search by student number (partial match)
    const query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.last_name, 
        s.student_number, 
        s.course_name
      FROM students s
      WHERE s.student_number LIKE $1 AND s.is_active = TRUE
      ORDER BY s.student_number
      LIMIT 10
    `;
    
    const searchTerm = `%${term}%`;
    const result = await pool.query(query, [searchTerm]);
 
    
    return res.status(200).json({
      success: true,
      students: result.rows
    });
  } catch (error) {
    console.error("Error searching students:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to search students",
      error: error.message
    });
  }
};

exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    const userId = req.user.id;


    if (!currentPassword || !newPassword) {
      return res.status(400).json({ message: "Current password and new password are required" });
    }

    const passwordRegex = /^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    if (!passwordRegex.test(newPassword)) {
      return res.status(400).json({ 
        message: "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character." 
      });
    }

    try {
 
      const result = await changePassword(userId, currentPassword, newPassword);
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error in changePassword model:", error);
      if (error.message === "Current password is incorrect") {
        return res.status(401).json({ message: error.message });
      }
      if (error.message === "User not found") {
        return res.status(404).json({ message: error.message });
      }
      throw error; 
    }
  } catch (error) {
    console.error("Error in changePassword controller:", error);
    res.status(500).json({ 
      message: "Error changing password",
      error: error.message 
    });
  }
};

exports.bulkDeleteStudentsByCourse = async (req, res) => {
  try {
    const { courseName } = req.body;

    if (!courseName) {
      return res.status(400).json({
        success: false,
        message: "Course name is required"
      });
    }

    const result = await bulkDeleteStudentsByCourse(courseName, false);

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.status(200).json({
      success: true,
      message: result.message,
      deletedCount: result.deletedCount,
      students: result.students
    });
  } catch (error) {
    console.error("Error in bulkDeleteStudentsByCourse controller:", error);
    res.status(500).json({
      success: false,
      message: "Error archiving students by course",
      error: error.message
    });
  }
};

// Bulk permanent delete students by course
exports.bulkPermanentDeleteStudentsByCourse = async (req, res) => {
  try {
    const { courseName } = req.body;

    if (!courseName) {
      return res.status(400).json({
        success: false,
        message: "Course name is required"
      });
    }

    const result = await bulkDeleteStudentsByCourse(courseName, true);

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.status(200).json({
      success: true,
      message: result.message,
      deletedCount: result.deletedCount,
      students: result.students
    });
  } catch (error) {
    console.error("Error in bulkPermanentDeleteStudentsByCourse controller:", error);
    res.status(500).json({
      success: false,
      message: "Error permanently deleting students by course",
      error: error.message
    });
  }
};

// Bulk permanent delete archived students by course
exports.bulkDeleteArchivedStudentsByCourse = async (req, res) => {
  try {
    const { courseName } = req.body;

    if (!courseName) {
      return res.status(400).json({
        success: false,
        message: "Course name is required"
      });
    }

    const result = await bulkDeleteArchivedStudentsByCourse(courseName);

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.status(200).json({
      success: true,
      message: result.message,
      deletedCount: result.deletedCount,
      students: result.students
    });
  } catch (error) {
    console.error("Error in bulkDeleteArchivedStudentsByCourse controller:", error);
    res.status(500).json({
      success: false,
      message: "Error permanently deleting archived students by course",
      error: error.message
    });
  }
};

// Delete all students (archive)
exports.deleteAllStudents = async (req, res) => {
  try {
    const result = await deleteAllStudents(false); // false = archive (soft delete)

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.status(200).json({
      success: true,
      message: result.message,
      deletedCount: result.deletedCount,
      students: result.students
    });
  } catch (error) {
    console.error("Error in deleteAllStudents controller:", error);
    res.status(500).json({
      success: false,
      message: "Error archiving all students",
      error: error.message
    });
  }
};

// Permanently delete all students
exports.permanentDeleteAllStudents = async (req, res) => {
  try {
    const result = await deleteAllStudents(true); // true = permanent delete

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.status(200).json({
      success: true,
      message: result.message,
      deletedCount: result.deletedCount,
      students: result.students
    });
  } catch (error) {
    console.error("Error in permanentDeleteAllStudents controller:", error);
    res.status(500).json({
      success: false,
      message: "Error permanently deleting all students",
      error: error.message
    });
  }
};